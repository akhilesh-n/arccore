/* Default linker script, for normal executables */
/* Linker script for 68HC12 executable (PROM).  */
OUTPUT_FORMAT("elf32-m68hc12", "elf32-m68hc12",
	      "elf32-m68hc12")
OUTPUT_ARCH(m68hc12)
ENTRY(_start)


MEMORY
{
  page0 (rwx) : ORIGIN = 0x0, LENGTH = 256

  /* RAM */
  data (rwx)  : ORIGIN = 0x2000, LENGTH = 8k

  eeprom (rx): ORIGIN = 0x0400, LENGTH = 3k
  text (rx)  : ORIGIN = 0x4000, LENGTH = 48k
  
  /* high fixed bank, reserve 0x100 vectors and security. */
  text_h (rx)  : ORIGIN = 0xc002, LENGTH = 16k-0x102
  vectors (rx)  : ORIGIN = 0xff80, LENGTH = 0x80
  
  /* Flash memory banks VMA:s */
  bank8  (rx)   : ORIGIN = 0x0f0000, LENGTH = 16k
  bank9  (rx)   : ORIGIN = 0x0f4000, LENGTH = 16k
  bank10 (rx)   : ORIGIN = 0x0f8000, LENGTH = 16k
  bank11 (rx)   : ORIGIN = 0x0fc000, LENGTH = 16k
  bank12 (rx)   : ORIGIN = 0x100000, LENGTH = 16k
  bank13 (rx)   : ORIGIN = 0x104000, LENGTH = 16k
  
  bank14 (rx)   : ORIGIN = 0x108000, LENGTH = 16k
  bank15 (rx)   : ORIGIN = 0x10c002, LENGTH = 16k-0x102
  
  /* Flash memory banks LMA:s */
  /* iSystem winIDEA */
  bank8_lma  (rx)   : ORIGIN = 0x0f0000, LENGTH = 16k
  bank9_lma  (rx)   : ORIGIN = 0x0f4000, LENGTH = 16k
  bank10_lma (rx)   : ORIGIN = 0x0f8000, LENGTH = 16k
  bank11_lma (rx)   : ORIGIN = 0x0fc000, LENGTH = 16k
  bank12_lma (rx)   : ORIGIN = 0x100000, LENGTH = 16k
  bank13_lma (rx)   : ORIGIN = 0x104000, LENGTH = 16k

  bank14_lma (rx)   : ORIGIN = 0x108000, LENGTH = 16k
  bank15_lma (rx)   : ORIGIN = 0x10c002, LENGTH = 16k-0x102
  vectors_lma (rx)  : ORIGIN = 0x10ff80, LENGTH = 0x80
  
  /* Freescale Codewarrior Hiwave (s19, TBDML)
  bank8_lma  (rx)   : ORIGIN = 0x388000, LENGTH = 16k
  bank9_lma  (rx)   : ORIGIN = 0x398000, LENGTH = 16k
  bank10_lma (rx)   : ORIGIN = 0x3a8000, LENGTH = 16k
  bank11_lma (rx)   : ORIGIN = 0x3b8000, LENGTH = 16k
  bank12_lma (rx)   : ORIGIN = 0x3c8000, LENGTH = 16k
  bank13_lma (rx)   : ORIGIN = 0x3d8000, LENGTH = 16k

  bank14_lma (rx)   : ORIGIN = 0x3e8000, LENGTH = 16k
  bank15_lma (rx)   : ORIGIN = 0x3f8002, LENGTH = 16k-0x102
  vectors_lma (rx)  : ORIGIN = 0x3fff80, LENGTH = 0x80
  */
}

/* Setup the stack on the top of the data memory bank.  */
PROVIDE (_stack = 0x4000);


SECTIONS
{
  .hash          : { *(.hash)		}
  .dynsym        : { *(.dynsym)		}
  .dynstr        : { *(.dynstr)		}
  .gnu.version		  : { *(.gnu.version) }
  .gnu.version_d	  : { *(.gnu.version_d) }
  .gnu.version_r	  : { *(.gnu.version_r) }
  
  /*
  .rel.text      :
    {
      *(.rel.text)
      *(.rel.text.*)
      *(.rel.gnu.linkonce.t.*)
    }
  .rela.text     :
    {
      *(.rela.text)
      *(.rela.text.*)
      *(.rela.gnu.linkonce.t.*)
    }
  .rel.data      :
    {
      *(.rel.data)
      *(.rel.data.*)
      *(.rel.gnu.linkonce.d.*)
    }
  .rela.data     :
    {
      *(.rela.data)
      *(.rela.data.*)
      *(.rela.gnu.linkonce.d.*)
    }
  .rel.rodata    :
    {
      *(.rel.rodata)
      *(.rel.rodata.*)
      *(.rel.gnu.linkonce.r.*)
    }
  .rela.rodata   :
    {
      *(.rela.rodata)
      *(.rela.rodata.*)
      *(.rela.gnu.linkonce.r.*)
    }
  .rel.sdata     :
    {
      *(.rel.sdata)
      *(.rel.sdata.*)
      *(.rel.gnu.linkonce.s.*)
    }
  .rela.sdata     :
    {
      *(.rela.sdata)
      *(.rela.sdata.*)
      *(.rela.gnu.linkonce.s.*)
    }
  .rel.sbss      :
    {
      *(.rel.sbss)
      *(.rel.sbss.*)
      *(.rel.gnu.linkonce.sb.*)
    }
  .rela.sbss     :
    {
      *(.rela.sbss)
      *(.rela.sbss.*)
      *(.rel.gnu.linkonce.sb.*)
    }
  .rel.bss       :
    {
      *(.rel.bss)
      *(.rel.bss.*)
      *(.rel.gnu.linkonce.b.*)
    }
  .rela.bss      :
    {
      *(.rela.bss)
      *(.rela.bss.*)
      *(.rela.gnu.linkonce.b.*)
    }
  .rel.stext		  : { *(.rel.stest) }
  .rela.stext		  : { *(.rela.stest) }
  .rel.etext		  : { *(.rel.etest) }
  .rela.etext		  : { *(.rela.etest) }
  .rel.sdata		  : { *(.rel.sdata) }
  .rela.sdata		  : { *(.rela.sdata) }
  .rel.edata		  : { *(.rel.edata) }
  .rela.edata		  : { *(.rela.edata) }
  .rel.eit_v		  : { *(.rel.eit_v) }
  .rela.eit_v		  : { *(.rela.eit_v) }
  .rel.ebss		  : { *(.rel.ebss) }
  .rela.ebss		  : { *(.rela.ebss) }
  .rel.srodata		  : { *(.rel.srodata) }
  .rela.srodata		  : { *(.rela.srodata) }
  .rel.erodata		  : { *(.rel.erodata) }
  .rela.erodata		  : { *(.rela.erodata) }
  .rel.got		  : { *(.rel.got) }
  .rela.got		  : { *(.rela.got) }
  .rel.ctors		  : { *(.rel.ctors) }
  .rela.ctors		  : { *(.rela.ctors) }
  .rel.dtors		  : { *(.rel.dtors) }
  .rela.dtors		  : { *(.rela.dtors) }
  .rel.init		  : { *(.rel.init) }
  .rela.init		  : { *(.rela.init) }
  .rel.fini		  : { *(.rel.fini) }
  .rela.fini		  : { *(.rela.fini) }
  .rel.plt		  : { *(.rel.plt) }
  .rela.plt		  : { *(.rela.plt) }
  */
  
  /* Concatenate .page0 sections.  Put them in the page0 memory bank
     unless we are creating a relocatable file.  */
  .page0 :
  {
    *(.page0)
  }  > page0
  
  
  /* PPAGE memory banks */

  .bank8 :
  {
    *(.bank8)
    *(.text.bank8*)
    
    /* BANK8 MODULES */
    Os_Cfg.o(.text)
    EcuM.o(.text)
    EcuM_Cfg.o(.text)
    EcuM_Callout_template.o(.text)
    Mcu.o(.text)
    event.o(.text)
    init.o(.text)
    arch.o(.text)
    task.o(.text)
    resource.o(.text)
    alarm.o(.text)
	
    . = ALIGN(2);
  } > bank8 AT>bank8_lma  =0xff

  .bank9 :
  {
    *(.bank9)
    *(.text.bank9*)

    /* BANK9 MODULES */
    sched_table.o(.text)
    counter.o(.text)
    sys_tick.o(.text)
    isr.o(.text)
    os_arctest.o(.text)
    irq.o(.text)
    Det.o(.text)
    xtoa.o(.text)
    newlib_port.o(.text)

    . = ALIGN(2);
  } > bank9 AT>bank9_lma =0xff


  .bank10 :
  {
    *(.bank10)
    *(.text.bank10*)

    /* BANK10 MODULES */	
	*_memcpy.o(.text)
	*_memset.o(.text)
	*_abort.o(.text)
	*_subdi3.o(.text)
	*_addsub_sf.o(.text)
	*udivmod.o(.text)
	/* *_negsi2.o(.text) */
	*_pack_sf.o(.text)
	*_unpack_sf.o(.text)
	*udivmodsi4.o(.text)
	/* *_ashlsi3.o(.text) */
	/* *_lshrsi3.o(.text) */
	*assert.o(.text)
	*div.o(.text)
	*fiprintf.o(.text)
	*reent.o(.text)
	*strcmp.o(.text)
	*strncpy.o(.text)
	*wcrtomb.o(.text)
	*wcsrtombs.o(.text)
	*wctomb_r.o(.text)
	*wsetup.o(.text)
	*fflush.o(.text)
	*findfp.o(.text)
	*freer.o(.text)
	*_memcpy.o(.text)
	
    . = ALIGN(2);
  } > bank10 AT>bank10_lma  =0xff


  .bank11 :
  {
    *(.bank11)
    *(.text.bank11*)

    /* BANK11 MODULES */
    Can*.o(.text)
    Pdu*.o(.text)
    Dio*.o(.text)

    . = ALIGN(2);
  } > bank11 AT>bank11_lma  =0xff


  .bank12 :
  {
    *(.bank12)
    *(.text.bank12*)

    /* BANK12 MODULES */
    Com*.o(.text)
    Port*.o(.text)

    . = ALIGN(2);
  } > bank12 AT>bank12_lma  =0xff


  .bank13 :
  {
    *(.bank13)
   *(.text.bank13*)

    /* BANK13 MODULES */
    Adc*.o(.text)
    . = ALIGN(2);
  } > bank13 AT>bank13_lma  =0xff
  
  
  /* Start of text section.  */
  .stext   :
  {
    *(.stext)
  }  > text AT>bank14_lma
  .init	  :
  {
    *(.init)
  } AT>bank14_lma =0
  .text  :
  {
    /* Put startup code at beginning so that _start keeps same address.  */
    /* Startup code.  */
    KEEP (*(.install0))	/* Section should setup the stack pointer.  */
    KEEP (*(.install1))	/* Place holder for applications.  */
    KEEP (*(.install2))	/* Optional installation of data sections in RAM.  */
    KEEP (*(.install3))	/* Place holder for applications.  */
    KEEP (*(.install4))	/* Section that calls the main.  */
    *(.init)
    *(.text)
    *(.text.*)
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
    *(.gnu.linkonce.t.*)
    *(.tramp)
    *(.tramp.*)
    /* Finish code.  */
    KEEP (*(.fini0))	/* Beginning of finish code (_exit symbol).  */
    KEEP (*(.fini1))	/* Place holder for applications.  */
    KEEP (*(.fini2))	/* C++ destructors.  */
    KEEP (*(.fini3))	/* Place holder for applications.  */
    KEEP (*(.fini4))	/* Runtime exit.  */
    _etext = .;
    PROVIDE (etext = .);
    . = ALIGN(2);
  }  > text AT>bank14_lma =0xa7a7a7a7
  
  .eh_frame   :
  {
    KEEP (*(.eh_frame))
  }  > text AT>bank14_lma
  
  .gcc_except_table   :
  {
    *(.gcc_except_table)
  }  > text AT>bank14_lma
  
  .rodata    :
  {
    *(.rodata)
    *(.rodata.*)
    *(.gnu.linkonce.r*)
    . = ALIGN(2);
  }  > text_h AT>bank15_lma =0xffffffff
  
  .rodata1   :
  {
    *(.rodata1)
    . = ALIGN(2);
  }  > text_h AT>bank15_lma =0xffffffff
  
  /* Constructor and destructor tables are in ROM.  */
  /*
  .ctors   :
  {
     PROVIDE (__CTOR_LIST__ = .);
    KEEP (*(.ctors))
     PROVIDE(__CTOR_END__ = .);
  }  > text
    .dtors	  :
  {
     PROVIDE(__DTOR_LIST__ = .);
    KEEP (*(.dtors))
     PROVIDE(__DTOR_END__ = .);
  }  > text
  .jcr   :
  {
    KEEP (*(.jcr))
  }  > text
  */
  
  /* Start of the data section image in ROM.  */
  __data_image = .;
  PROVIDE (__data_image = .);
  /* All read-only sections that normally go in PROM must be above.
     We construct the DATA image section in PROM at end of all these
     read-only sections.  The data image must be copied at init time.
     Refer to GNU ld, Section 3.6.8.2 Output Section LMA.  */
  .data    : /* AT (__data_image) */
  {
    __data_section_start = .;
    PROVIDE (__data_section_start = .);
    *(.sdata)
    *(.data)
    *(.data.*)
    *(.data1)
    *(.gnu.linkonce.d.*)
    CONSTRUCTORS
    _edata  =  .;
    PROVIDE (edata = .);
    . = ALIGN(2);
  }  > data AT>bank15_lma =0xffffffff
  __data_section_size = SIZEOF(.data);
  PROVIDE (__data_section_size = SIZEOF(.data));
  __data_image_end = __data_image + __data_section_size;
  
  .ramlog :
  {
    *(.winidea_port)
  	*(.ramlog)
  	*(.dem_eventmemory_pri)
  } > data
  
/* SCz: this does not work yet... This is supposed to force the loading
   of _map_data.o (from libgcc.a) when the .data section is not empty.
   By doing so, this should bring the code that copies the .data section
   from ROM to RAM at init time.
  ___pre_comp_data_size = SIZEOF(.data);
  __install_data_sections = ___pre_comp_data_size > 0 ?
		__map_data_sections : 0;
*/
  /* .install  :
  {
    . = _data_image_end;
  }  > text */
  /* Relocation for some bss and data sections.  */
  .bss   :
  {
    __bss_start = .;
    *(.softregs)
    *(.sbss)
    *(.scommon)
    *(.dynbss)
    *(.bss)
    *(.bss.*)
    *(.gnu.linkonce.b.*)
    *(COMMON)
    PROVIDE (_end = .);
  }  > data AT>bank15_lma
  __bss_size = SIZEOF(.bss);
  PROVIDE (__bss_size = SIZEOF(.bss));
  .eeprom   :
  {
    *(.eeprom)
    *(.eeprom.*)
  }  > eeprom
  /* If the 'vectors_addr' symbol is defined, it indicates the start address
     of interrupt vectors.  This depends on the 68HC11 operating mode:
			Addr
     Single chip	0xffc0
     Extended mode	0xffc0
     Bootstrap		0x00c0
     Test		0xbfc0
     In general, the vectors address is 0xffc0.  This can be overriden
     with the '-defsym vectors_addr=0xbfc0' ld option.
     Note: for the bootstrap mode, the interrupt vectors are at 0xbfc0 but
     they are redirected to 0x00c0 by the internal PROM.  Application's vectors
     must also consist of jump instructions (see Motorola's manual).  */
/*
  PROVIDE (_vectors_addr = DEFINED (vectors_addr) ? vectors_addr : 0xffc0);
  .vectors DEFINED (vectors_addr) ? vectors_addr : 0xffc0 :
  */
  .vectors :
  {
    KEEP (*(.vectors))
  } >vectors AT>vectors_lma
  
  /* Stabs debugging sections.  */
  .stab		 0 : { *(.stab) }
  .stabstr	 0 : { *(.stabstr) }
  .stab.excl	 0 : { *(.stab.excl) }
  .stab.exclstr	 0 : { *(.stab.exclstr) }
  .stab.index	 0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment	 0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.
     Treatment of DWARF debug section must be at end of the linker
     script to avoid problems when there are undefined symbols. It's necessary
     to avoid that the DWARF section is relocated before such undefined
     symbols are found.  */
  /* DWARF 1 */
  .debug	 0 : { *(.debug) }
  .line		 0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo 0 : { *(.debug_srcinfo) }
  .debug_sfnames 0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info) *(.gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
}
