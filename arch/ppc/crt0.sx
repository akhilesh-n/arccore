#include "asm_ppc.h"

#if defined(__GNUC__)
.section ".rcw","ax"
.balign  4
#elif defined(__CWCC__)
.section .rcw,4,"r"
#endif

.global _resetconfiguration
_resetconfiguration:
	.byte  0x00   #no watchdog
	.byte  0x5A   #Boot identifier
	.byte  0x00
	.byte  0x00
	.long _start


	.extern _SDA_BASE_
	.extern _SDA2_BASE_
	.extern __SP_INIT
	.extern __DATA_RAM
	.extern __DATA_END
	.extern __BSS_START
	.extern __BSS_END
	.extern __DATA_ROM
	.extern exit
	.extern main
	
	.text
	.align		4

	.globl	_start
	.type	_start,@function

	// Good information about the E500 is freescale doc: E500ABIUG.pdf
	

.global _redled
_redled:
	// mpc5567qrtech: light up led K2 
	li r0, 0x0202
	lis r3, 0xC3F9013A@h
	ori r3, r3, 0xC3F90130@l
	stw r0, 8(r3)
	b _exit

__start:
_start:
	// Set up the reserved registers in EABI: r1,r2 and r13

	// r1, stack pointer
	lis	r1,__SP_INIT@h
	ori	r1,r1,__SP_INIT@l

	// r13, base of .sdata
	lis	r13,_SDA_BASE_@h
	ori	r13,r13,_SDA_BASE_@l

	// r2, base of .sdata2 and .sbss2
	lis	r2,_SDA2_BASE_@h
	ori	r2,r2,_SDA2_BASE_@l

	// make space for initial backchain..
	subi    r1,r1,16

/* Store winIDEA terminal connected status */
#if defined(USE_TTY_WINIDEA)
	lis	r3,g_TConn@h
	ori	r3,r3,g_TConn@l
	lbz r4,0(r3)
#endif

	/*  Clear all SRAM */
init_RAM:
	lis r11,0x4000 # base address of the SRAM, 64-bit word aligned
	ori r11,r11,0 # not needed for this address but could be for others
	li r12,640 # loop counter to get all of SRAM;
	/* 80k/4 bytes/32 GPRs = 640 */
	mtctr r12

init_ram_loop:
	stmw r0,0(r11) # write all 32 GPRs to SRAM
	addi r11,r11,128 # inc the ram ptr; 32 GPRs * 4 bytes = 128
	bdnz init_ram_loop # loop for 80k of SRAM

/* Restore winIDEA terminal connected status */
#if defined(USE_TTY_WINIDEA)
	stb		r4,0(r3)
#endif

	// Copy initialized data from ROM to RAM
	lis		r3,__DATA_ROM@h
	ori		r3,r3,__DATA_ROM@l
	lis		r4,__DATA_RAM@h
	ori		r4,r4,__DATA_RAM@l
	lis		r5,__DATA_END@h
	ori		r5,r5,__DATA_END@l

	cmplw	r3,r4
	beq		skip_data
	cmplw	r4,r5
	beq		skip_data
	subi	r3,r3,1
	subi	r4,r4,1
copy_data:
	lbzu	r6,1(r3)
	stbu	r6,1(r4)
	cmplw	r4,r5
	bne+	copy_data
skip_data:

	/* Clear uninitialized data( holds both bss and sbss ) */
	lis		r3,__BSS_START@h
	ori		r3,r3,__BSS_START@l
	lis		r4,__BSS_END@h
	ori		r4,r4,__BSS_END@l
	cmplw	r3,r4
	beq		skip_bss
	li		r0,0
	subi	r3,r3,1
copy_bss:
	stbu	r0,1(r3)
	cmplw	r3,r4
	bne+	copy_bss
skip_bss:
	/* Call main() with argc set to 1 and argv ignored */
	li	r3,1
	bl	main

	/* Call exit() with the return value from main() as argument */
	b	exit

	.globl	_exit
_exit:
	b	_exit


	.end
