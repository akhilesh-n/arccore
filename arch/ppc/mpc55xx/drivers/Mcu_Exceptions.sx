
#define _ASSEMBLER_
#include "asm_ppc.h"
#include "asm_book_e.h"
#ifdef USE_KERNEL
#include "asm_offset.h"
#endif

#define  INTC_IACKR  0xfff48010
#define  INTC_EOIR   0xfff48018

#define SIU_MIDR    0xfffe8004
#define SIMULATOR(_reg,_inst,_label)   \
         lis    _reg, SIU_MIDR@ha; \
         lwz    _reg, SIU_MIDR@l(_reg); \
         cmpwi  0,_reg,0; \
         _inst    _label;

		.section .text
//---------------------------------------------------------------
// just a small decrementer exception to trigger soft interrupt
// in the INTC( simluator addon )


		#define INTC_SSCIR7 0xFFF48027
		.global dec_exception

dec_exception:
    stwu  	r3,-8(sp)
    stw   	r4,4(sp)

    # ack dec int
    lis 	r3,0x0800
    mtspr   SPR_TSR,r3

    # Set soft int
    li  	r4,2
    lis     r3, INTC_SSCIR7@ha
    stb     r4, INTC_SSCIR7@l(r3)

    lwz     r3,0(sp)
    lwz     r4,4(sp)
    addi  	sp,sp,8
    rfi


EXCEPTION_CSRRx(exception_IVOR0,320)    //#CRITICAL_INPUT_EXCEPTION
EXCEPTION_CSRRx(exception_IVOR1,321)    //#MACHINE_CHECK_EXCEPTION
EXCEPTION_SRRx(exception_IVOR2,322)     //#DATA_STORAGE_EXCEPTION
EXCEPTION_SRRx(exception_IVOR3,323)     //#INSTRUCTION_STORAGE_EXCEPTION
// IVOR4, defined elsewhere
EXCEPTION_SRRx(exception_IVOR5,325)     //#ALIGNMENT_EXCEPTION
EXCEPTION_SRRx(exception_IVOR6,326)     //#PROGRAM_EXCEPTION
EXCEPTION_SRRx(exception_IVOR7,327)     //#FLOATING_POINT_EXCEPTION
EXCEPTION_SRRx(exception_IVOR8,328)     //#SYSTEM_CALL_EXCEPTION)
EXCEPTION_SRRx(exception_IVOR9,329)
// IVOR10, defined elsewhere
EXCEPTION_SRRx(exception_IVOR11,331)    //#FIXED_INTERVAL_TIMER_EXCEPTION
EXCEPTION_SRRx(exception_IVOR12,332)    //#WATCHDOG_TIMER_EXCEPTION
EXCEPTION_SRRx(exception_IVOR13,333)    //#DATA_TLB_EXCEPTION
EXCEPTION_SRRx(exception_IVOR14,334)    //#INSTRUCTION_TLB_EXCEPTION


//
//   EXC_FRAME
//   VGPR_FRAME
//  NVGPR_FRAME
//

		.global exception_IVOR4
		.global os_lc_restore
		.balign 16
exception_IVOR4:

	SAVE_WORK_AND_MORE
	// Save registers NOT preserved by functions
	SAVE_VGPR(1,C_SIZE);
	// Save registers preserved by functions
	addi 	r1,r1,C_SIZE
	SAVE_NVGPR(1,0);
	addi	r1,r1,-C_SIZE

	// TODO: Why 0, can't remember
    li    r3,0
    stw   r3,EXC_VECTOR_OFF(r4)
	mr	  r4,r1		// save stack

#ifdef USE_KERNEL
	li 		r3,LC_PATTERN
	stw		r3,C_CONTEXT_OFF(sp)

	// Switch to interrupt stack if at depth 0
	LOAD_IND_32(3,os_sys+SYS_INT_NEST_CNT)
	cmpli	0,r3,0
	bne-	on_int_stack
	// Load the interrupt stack
	LOAD_IND_32(sp,os_sys+SYS_INT_STACK)
on_int_stack:

#endif

    lis   r3, IntCtrl_Entry@h
    ori   r3, r3,IntCtrl_Entry@l

    mtlr  r3
    mr    r3,r4  /* "old" stack as arg1 */
    blrl

#ifdef USE_KERNEL
// Set the retun value as new stack
	mr		sp,r3
#endif
	addi 	r1,r1,C_SIZE
	RESTORE_NVGPR(1,0)
	addi	r1,r1,-C_SIZE
	RESTORE_VGPR(1,C_SIZE)

	RESTORE_WORK_AND_MORE
	rfi

bad_int:
	b bad_int

# Force this jump table to this address to match the
# value written to z1 IVPR
.section ".exception_tbl","ax"
.balign 0x0800  //TODO: 1000 eller 800?
.global exception_tbl

# The .skip directive aligns the branch instructions
#   to the irq vector offsets
exception_tbl:
    b      exception_IVOR0
    .skip   +0xc
    b      exception_IVOR1
    .skip   +0xc
    b      exception_IVOR2
    .skip   +0xc
    b      exception_IVOR3
    .skip   +0xc
    b      exception_IVOR4
    .skip   +0xc
    b      exception_IVOR5
    .skip   +0xc
    b      exception_IVOR6
    .skip   +0xc
    b      exception_IVOR7
    .skip   +0xc
    b      exception_IVOR8
    .skip   +0xc
    b      exception_IVOR9
    .skip   +0xc
    b      dec_exception
    //b	   exception_IVOR10
    .skip   +0xc
    b      exception_IVOR11
    .skip   +0xc
    b      exception_IVOR12
    .skip   +0xc
    b      exception_IVOR13
    .skip   +0xc
    b      exception_IVOR14
    .skip   +0xc
    b      bad_int
